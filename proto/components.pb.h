// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components.proto

#ifndef PROTOBUF_components_2eproto__INCLUDED
#define PROTOBUF_components_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tec {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_components_2eproto();
void protobuf_AssignDesc_components_2eproto();
void protobuf_ShutdownFile_components_2eproto();

class Renderable;
class Position;
class Orientation;
class View;
class Animation;
class Scale;
class CollisionBody;
class CollisionBody_Box;
class CollisionBody_Sphere;
class CollisionBody_Capsule;
class Velocity;
class AudioSource;
class Light;
class Light_Attenuation;
class Component;
class Entity;
class EntityList;

// ===================================================================

class Renderable : public ::google::protobuf::Message {
 public:
  Renderable();
  virtual ~Renderable();

  Renderable(const Renderable& from);

  inline Renderable& operator=(const Renderable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Renderable& default_instance();

  void Swap(Renderable* other);

  // implements Message ----------------------------------------------

  inline Renderable* New() const { return New(NULL); }

  Renderable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Renderable& from);
  void MergeFrom(const Renderable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Renderable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string shader_name = 1;
  bool has_shader_name() const;
  void clear_shader_name();
  static const int kShaderNameFieldNumber = 1;
  const ::std::string& shader_name() const;
  void set_shader_name(const ::std::string& value);
  void set_shader_name(const char* value);
  void set_shader_name(const char* value, size_t size);
  ::std::string* mutable_shader_name();
  ::std::string* release_shader_name();
  void set_allocated_shader_name(::std::string* shader_name);

  // optional string mesh_name = 2;
  bool has_mesh_name() const;
  void clear_mesh_name();
  static const int kMeshNameFieldNumber = 2;
  const ::std::string& mesh_name() const;
  void set_mesh_name(const ::std::string& value);
  void set_mesh_name(const char* value);
  void set_mesh_name(const char* value, size_t size);
  ::std::string* mutable_mesh_name();
  ::std::string* release_mesh_name();
  void set_allocated_mesh_name(::std::string* mesh_name);

  // optional bool hidden = 3;
  bool has_hidden() const;
  void clear_hidden();
  static const int kHiddenFieldNumber = 3;
  bool hidden() const;
  void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.Renderable)
 private:
  inline void set_has_shader_name();
  inline void clear_has_shader_name();
  inline void set_has_mesh_name();
  inline void clear_has_mesh_name();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr shader_name_;
  ::google::protobuf::internal::ArenaStringPtr mesh_name_;
  bool hidden_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Renderable* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  void Swap(Orientation* other);

  // implements Message ----------------------------------------------

  inline Orientation* New() const { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Orientation)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Orientation* default_instance_;
};
// -------------------------------------------------------------------

class View : public ::google::protobuf::Message {
 public:
  View();
  virtual ~View();

  View(const View& from);

  inline View& operator=(const View& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const View& default_instance();

  void Swap(View* other);

  // implements Message ----------------------------------------------

  inline View* New() const { return New(NULL); }

  View* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const View& from);
  void MergeFrom(const View& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(View* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool active = 1;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 1;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:tec.proto.View)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static View* default_instance_;
};
// -------------------------------------------------------------------

class Animation : public ::google::protobuf::Message {
 public:
  Animation();
  virtual ~Animation();

  Animation(const Animation& from);

  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Animation& default_instance();

  void Swap(Animation* other);

  // implements Message ----------------------------------------------

  inline Animation* New() const { return New(NULL); }

  Animation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Animation& from);
  void MergeFrom(const Animation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Animation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string animation_name = 1;
  bool has_animation_name() const;
  void clear_animation_name();
  static const int kAnimationNameFieldNumber = 1;
  const ::std::string& animation_name() const;
  void set_animation_name(const ::std::string& value);
  void set_animation_name(const char* value);
  void set_animation_name(const char* value, size_t size);
  ::std::string* mutable_animation_name();
  ::std::string* release_animation_name();
  void set_allocated_animation_name(::std::string* animation_name);

  // @@protoc_insertion_point(class_scope:tec.proto.Animation)
 private:
  inline void set_has_animation_name();
  inline void clear_has_animation_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr animation_name_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Animation* default_instance_;
};
// -------------------------------------------------------------------

class Scale : public ::google::protobuf::Message {
 public:
  Scale();
  virtual ~Scale();

  Scale(const Scale& from);

  inline Scale& operator=(const Scale& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scale& default_instance();

  void Swap(Scale* other);

  // implements Message ----------------------------------------------

  inline Scale* New() const { return New(NULL); }

  Scale* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scale& from);
  void MergeFrom(const Scale& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Scale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Scale)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Scale* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Box : public ::google::protobuf::Message {
 public:
  CollisionBody_Box();
  virtual ~CollisionBody_Box();

  CollisionBody_Box(const CollisionBody_Box& from);

  inline CollisionBody_Box& operator=(const CollisionBody_Box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Box& default_instance();

  void Swap(CollisionBody_Box* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Box* New() const { return New(NULL); }

  CollisionBody_Box* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Box& from);
  void MergeFrom(const CollisionBody_Box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x_extent = 1;
  bool has_x_extent() const;
  void clear_x_extent();
  static const int kXExtentFieldNumber = 1;
  float x_extent() const;
  void set_x_extent(float value);

  // required float y_extent = 2;
  bool has_y_extent() const;
  void clear_y_extent();
  static const int kYExtentFieldNumber = 2;
  float y_extent() const;
  void set_y_extent(float value);

  // required float z_extent = 3;
  bool has_z_extent() const;
  void clear_z_extent();
  static const int kZExtentFieldNumber = 3;
  float z_extent() const;
  void set_z_extent(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Box)
 private:
  inline void set_has_x_extent();
  inline void clear_has_x_extent();
  inline void set_has_y_extent();
  inline void clear_has_y_extent();
  inline void set_has_z_extent();
  inline void clear_has_z_extent();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_extent_;
  float y_extent_;
  float z_extent_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Box* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Sphere : public ::google::protobuf::Message {
 public:
  CollisionBody_Sphere();
  virtual ~CollisionBody_Sphere();

  CollisionBody_Sphere(const CollisionBody_Sphere& from);

  inline CollisionBody_Sphere& operator=(const CollisionBody_Sphere& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Sphere& default_instance();

  void Swap(CollisionBody_Sphere* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Sphere* New() const { return New(NULL); }

  CollisionBody_Sphere* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Sphere& from);
  void MergeFrom(const CollisionBody_Sphere& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Sphere* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float radius = 1;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Sphere)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Sphere* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody_Capsule : public ::google::protobuf::Message {
 public:
  CollisionBody_Capsule();
  virtual ~CollisionBody_Capsule();

  CollisionBody_Capsule(const CollisionBody_Capsule& from);

  inline CollisionBody_Capsule& operator=(const CollisionBody_Capsule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody_Capsule& default_instance();

  void Swap(CollisionBody_Capsule* other);

  // implements Message ----------------------------------------------

  inline CollisionBody_Capsule* New() const { return New(NULL); }

  CollisionBody_Capsule* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody_Capsule& from);
  void MergeFrom(const CollisionBody_Capsule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody_Capsule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float radius = 1;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  float radius() const;
  void set_radius(float value);

  // required float height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody.Capsule)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  float height_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody_Capsule* default_instance_;
};
// -------------------------------------------------------------------

class CollisionBody : public ::google::protobuf::Message {
 public:
  CollisionBody();
  virtual ~CollisionBody();

  CollisionBody(const CollisionBody& from);

  inline CollisionBody& operator=(const CollisionBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionBody& default_instance();

  enum ShapeCase {
    kBox = 3,
    kSphere = 4,
    kCapsule = 5,
    SHAPE_NOT_SET = 0,
  };

  void Swap(CollisionBody* other);

  // implements Message ----------------------------------------------

  inline CollisionBody* New() const { return New(NULL); }

  CollisionBody* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionBody& from);
  void MergeFrom(const CollisionBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CollisionBody_Box Box;
  typedef CollisionBody_Sphere Sphere;
  typedef CollisionBody_Capsule Capsule;

  // accessors -------------------------------------------------------

  // optional bool disable_deactivation = 1;
  bool has_disable_deactivation() const;
  void clear_disable_deactivation();
  static const int kDisableDeactivationFieldNumber = 1;
  bool disable_deactivation() const;
  void set_disable_deactivation(bool value);

  // optional bool disable_rotation = 2;
  bool has_disable_rotation() const;
  void clear_disable_rotation();
  static const int kDisableRotationFieldNumber = 2;
  bool disable_rotation() const;
  void set_disable_rotation(bool value);

  // optional .tec.proto.CollisionBody.Box box = 3;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 3;
  const ::tec::proto::CollisionBody_Box& box() const;
  ::tec::proto::CollisionBody_Box* mutable_box();
  ::tec::proto::CollisionBody_Box* release_box();
  void set_allocated_box(::tec::proto::CollisionBody_Box* box);

  // optional .tec.proto.CollisionBody.Sphere sphere = 4;
  bool has_sphere() const;
  void clear_sphere();
  static const int kSphereFieldNumber = 4;
  const ::tec::proto::CollisionBody_Sphere& sphere() const;
  ::tec::proto::CollisionBody_Sphere* mutable_sphere();
  ::tec::proto::CollisionBody_Sphere* release_sphere();
  void set_allocated_sphere(::tec::proto::CollisionBody_Sphere* sphere);

  // optional .tec.proto.CollisionBody.Capsule capsule = 5;
  bool has_capsule() const;
  void clear_capsule();
  static const int kCapsuleFieldNumber = 5;
  const ::tec::proto::CollisionBody_Capsule& capsule() const;
  ::tec::proto::CollisionBody_Capsule* mutable_capsule();
  ::tec::proto::CollisionBody_Capsule* release_capsule();
  void set_allocated_capsule(::tec::proto::CollisionBody_Capsule* capsule);

  // optional float mass = 6;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 6;
  float mass() const;
  void set_mass(float value);

  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.CollisionBody)
 private:
  inline void set_has_disable_deactivation();
  inline void clear_has_disable_deactivation();
  inline void set_has_disable_rotation();
  inline void clear_has_disable_rotation();
  inline void set_has_box();
  inline void set_has_sphere();
  inline void set_has_capsule();
  inline void set_has_mass();
  inline void clear_has_mass();

  inline bool has_shape() const;
  void clear_shape();
  inline void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_deactivation_;
  bool disable_rotation_;
  float mass_;
  union ShapeUnion {
    ShapeUnion() {}
    ::tec::proto::CollisionBody_Box* box_;
    ::tec::proto::CollisionBody_Sphere* sphere_;
    ::tec::proto::CollisionBody_Capsule* capsule_;
  } shape_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static CollisionBody* default_instance_;
};
// -------------------------------------------------------------------

class Velocity : public ::google::protobuf::Message {
 public:
  Velocity();
  virtual ~Velocity();

  Velocity(const Velocity& from);

  inline Velocity& operator=(const Velocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Velocity& default_instance();

  void Swap(Velocity* other);

  // implements Message ----------------------------------------------

  inline Velocity* New() const { return New(NULL); }

  Velocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Velocity& from);
  void MergeFrom(const Velocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Velocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float linear_x = 1;
  bool has_linear_x() const;
  void clear_linear_x();
  static const int kLinearXFieldNumber = 1;
  float linear_x() const;
  void set_linear_x(float value);

  // optional float linear_y = 2;
  bool has_linear_y() const;
  void clear_linear_y();
  static const int kLinearYFieldNumber = 2;
  float linear_y() const;
  void set_linear_y(float value);

  // optional float linear_z = 3;
  bool has_linear_z() const;
  void clear_linear_z();
  static const int kLinearZFieldNumber = 3;
  float linear_z() const;
  void set_linear_z(float value);

  // optional float angular_x = 4;
  bool has_angular_x() const;
  void clear_angular_x();
  static const int kAngularXFieldNumber = 4;
  float angular_x() const;
  void set_angular_x(float value);

  // optional float angular_y = 5;
  bool has_angular_y() const;
  void clear_angular_y();
  static const int kAngularYFieldNumber = 5;
  float angular_y() const;
  void set_angular_y(float value);

  // optional float angular_z = 6;
  bool has_angular_z() const;
  void clear_angular_z();
  static const int kAngularZFieldNumber = 6;
  float angular_z() const;
  void set_angular_z(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Velocity)
 private:
  inline void set_has_linear_x();
  inline void clear_has_linear_x();
  inline void set_has_linear_y();
  inline void clear_has_linear_y();
  inline void set_has_linear_z();
  inline void clear_has_linear_z();
  inline void set_has_angular_x();
  inline void clear_has_angular_x();
  inline void set_has_angular_y();
  inline void clear_has_angular_y();
  inline void set_has_angular_z();
  inline void clear_has_angular_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float linear_x_;
  float linear_y_;
  float linear_z_;
  float angular_x_;
  float angular_y_;
  float angular_z_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Velocity* default_instance_;
};
// -------------------------------------------------------------------

class AudioSource : public ::google::protobuf::Message {
 public:
  AudioSource();
  virtual ~AudioSource();

  AudioSource(const AudioSource& from);

  inline AudioSource& operator=(const AudioSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioSource& default_instance();

  void Swap(AudioSource* other);

  // implements Message ----------------------------------------------

  inline AudioSource* New() const { return New(NULL); }

  AudioSource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioSource& from);
  void MergeFrom(const AudioSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool looping = 1;
  bool has_looping() const;
  void clear_looping();
  static const int kLoopingFieldNumber = 1;
  bool looping() const;
  void set_looping(bool value);

  // optional string audio_name = 2;
  bool has_audio_name() const;
  void clear_audio_name();
  static const int kAudioNameFieldNumber = 2;
  const ::std::string& audio_name() const;
  void set_audio_name(const ::std::string& value);
  void set_audio_name(const char* value);
  void set_audio_name(const char* value, size_t size);
  ::std::string* mutable_audio_name();
  ::std::string* release_audio_name();
  void set_allocated_audio_name(::std::string* audio_name);

  // optional bool playing = 3;
  bool has_playing() const;
  void clear_playing();
  static const int kPlayingFieldNumber = 3;
  bool playing() const;
  void set_playing(bool value);

  // optional uint32 volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  ::google::protobuf::uint32 volume() const;
  void set_volume(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tec.proto.AudioSource)
 private:
  inline void set_has_looping();
  inline void clear_has_looping();
  inline void set_has_audio_name();
  inline void clear_has_audio_name();
  inline void set_has_playing();
  inline void clear_has_playing();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr audio_name_;
  bool looping_;
  bool playing_;
  ::google::protobuf::uint32 volume_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static AudioSource* default_instance_;
};
// -------------------------------------------------------------------

class Light_Attenuation : public ::google::protobuf::Message {
 public:
  Light_Attenuation();
  virtual ~Light_Attenuation();

  Light_Attenuation(const Light_Attenuation& from);

  inline Light_Attenuation& operator=(const Light_Attenuation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light_Attenuation& default_instance();

  void Swap(Light_Attenuation* other);

  // implements Message ----------------------------------------------

  inline Light_Attenuation* New() const { return New(NULL); }

  Light_Attenuation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light_Attenuation& from);
  void MergeFrom(const Light_Attenuation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light_Attenuation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float constant = 1;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 1;
  float constant() const;
  void set_constant(float value);

  // optional float linear = 2;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 2;
  float linear() const;
  void set_linear(float value);

  // optional float exponential = 3;
  bool has_exponential() const;
  void clear_exponential();
  static const int kExponentialFieldNumber = 3;
  float exponential() const;
  void set_exponential(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Light.Attenuation)
 private:
  inline void set_has_constant();
  inline void clear_has_constant();
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_exponential();
  inline void clear_has_exponential();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float constant_;
  float linear_;
  float exponential_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Light_Attenuation* default_instance_;
};
// -------------------------------------------------------------------

class Light : public ::google::protobuf::Message {
 public:
  Light();
  virtual ~Light();

  Light(const Light& from);

  inline Light& operator=(const Light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Light& default_instance();

  void Swap(Light* other);

  // implements Message ----------------------------------------------

  inline Light* New() const { return New(NULL); }

  Light* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Light& from);
  void MergeFrom(const Light& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Light_Attenuation Attenuation;

  // accessors -------------------------------------------------------

  // optional float color_x = 1;
  bool has_color_x() const;
  void clear_color_x();
  static const int kColorXFieldNumber = 1;
  float color_x() const;
  void set_color_x(float value);

  // optional float color_y = 2;
  bool has_color_y() const;
  void clear_color_y();
  static const int kColorYFieldNumber = 2;
  float color_y() const;
  void set_color_y(float value);

  // optional float color_z = 3;
  bool has_color_z() const;
  void clear_color_z();
  static const int kColorZFieldNumber = 3;
  float color_z() const;
  void set_color_z(float value);

  // optional float ambient_intensity = 4;
  bool has_ambient_intensity() const;
  void clear_ambient_intensity();
  static const int kAmbientIntensityFieldNumber = 4;
  float ambient_intensity() const;
  void set_ambient_intensity(float value);

  // optional float diffuse_intensity = 5;
  bool has_diffuse_intensity() const;
  void clear_diffuse_intensity();
  static const int kDiffuseIntensityFieldNumber = 5;
  float diffuse_intensity() const;
  void set_diffuse_intensity(float value);

  // optional .tec.proto.Light.Attenuation attenuation = 6;
  bool has_attenuation() const;
  void clear_attenuation();
  static const int kAttenuationFieldNumber = 6;
  const ::tec::proto::Light_Attenuation& attenuation() const;
  ::tec::proto::Light_Attenuation* mutable_attenuation();
  ::tec::proto::Light_Attenuation* release_attenuation();
  void set_allocated_attenuation(::tec::proto::Light_Attenuation* attenuation);

  // optional float cutoff = 7;
  bool has_cutoff() const;
  void clear_cutoff();
  static const int kCutoffFieldNumber = 7;
  float cutoff() const;
  void set_cutoff(float value);

  // @@protoc_insertion_point(class_scope:tec.proto.Light)
 private:
  inline void set_has_color_x();
  inline void clear_has_color_x();
  inline void set_has_color_y();
  inline void clear_has_color_y();
  inline void set_has_color_z();
  inline void clear_has_color_z();
  inline void set_has_ambient_intensity();
  inline void clear_has_ambient_intensity();
  inline void set_has_diffuse_intensity();
  inline void clear_has_diffuse_intensity();
  inline void set_has_attenuation();
  inline void clear_has_attenuation();
  inline void set_has_cutoff();
  inline void clear_has_cutoff();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float color_x_;
  float color_y_;
  float color_z_;
  float ambient_intensity_;
  ::tec::proto::Light_Attenuation* attenuation_;
  float diffuse_intensity_;
  float cutoff_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Light* default_instance_;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  enum ComponentCase {
    kRenderable = 1,
    kPosition = 2,
    kOrientation = 3,
    kView = 4,
    kAnimation = 5,
    kScale = 6,
    kCollisionBody = 7,
    kVelocity = 8,
    kAudioSource = 9,
    kLight = 10,
    COMPONENT_NOT_SET = 0,
  };

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  inline Component* New() const { return New(NULL); }

  Component* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Component* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tec.proto.Renderable renderable = 1;
  bool has_renderable() const;
  void clear_renderable();
  static const int kRenderableFieldNumber = 1;
  const ::tec::proto::Renderable& renderable() const;
  ::tec::proto::Renderable* mutable_renderable();
  ::tec::proto::Renderable* release_renderable();
  void set_allocated_renderable(::tec::proto::Renderable* renderable);

  // optional .tec.proto.Position position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::tec::proto::Position& position() const;
  ::tec::proto::Position* mutable_position();
  ::tec::proto::Position* release_position();
  void set_allocated_position(::tec::proto::Position* position);

  // optional .tec.proto.Orientation orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::tec::proto::Orientation& orientation() const;
  ::tec::proto::Orientation* mutable_orientation();
  ::tec::proto::Orientation* release_orientation();
  void set_allocated_orientation(::tec::proto::Orientation* orientation);

  // optional .tec.proto.View view = 4;
  bool has_view() const;
  void clear_view();
  static const int kViewFieldNumber = 4;
  const ::tec::proto::View& view() const;
  ::tec::proto::View* mutable_view();
  ::tec::proto::View* release_view();
  void set_allocated_view(::tec::proto::View* view);

  // optional .tec.proto.Animation animation = 5;
  bool has_animation() const;
  void clear_animation();
  static const int kAnimationFieldNumber = 5;
  const ::tec::proto::Animation& animation() const;
  ::tec::proto::Animation* mutable_animation();
  ::tec::proto::Animation* release_animation();
  void set_allocated_animation(::tec::proto::Animation* animation);

  // optional .tec.proto.Scale Scale = 6;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 6;
  const ::tec::proto::Scale& scale() const;
  ::tec::proto::Scale* mutable_scale();
  ::tec::proto::Scale* release_scale();
  void set_allocated_scale(::tec::proto::Scale* scale);

  // optional .tec.proto.CollisionBody collision_body = 7;
  bool has_collision_body() const;
  void clear_collision_body();
  static const int kCollisionBodyFieldNumber = 7;
  const ::tec::proto::CollisionBody& collision_body() const;
  ::tec::proto::CollisionBody* mutable_collision_body();
  ::tec::proto::CollisionBody* release_collision_body();
  void set_allocated_collision_body(::tec::proto::CollisionBody* collision_body);

  // optional .tec.proto.Velocity velocity = 8;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 8;
  const ::tec::proto::Velocity& velocity() const;
  ::tec::proto::Velocity* mutable_velocity();
  ::tec::proto::Velocity* release_velocity();
  void set_allocated_velocity(::tec::proto::Velocity* velocity);

  // optional .tec.proto.AudioSource audio_source = 9;
  bool has_audio_source() const;
  void clear_audio_source();
  static const int kAudioSourceFieldNumber = 9;
  const ::tec::proto::AudioSource& audio_source() const;
  ::tec::proto::AudioSource* mutable_audio_source();
  ::tec::proto::AudioSource* release_audio_source();
  void set_allocated_audio_source(::tec::proto::AudioSource* audio_source);

  // optional .tec.proto.Light light = 10;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 10;
  const ::tec::proto::Light& light() const;
  ::tec::proto::Light* mutable_light();
  ::tec::proto::Light* release_light();
  void set_allocated_light(::tec::proto::Light* light);

  ComponentCase component_case() const;
  // @@protoc_insertion_point(class_scope:tec.proto.Component)
 private:
  inline void set_has_renderable();
  inline void set_has_position();
  inline void set_has_orientation();
  inline void set_has_view();
  inline void set_has_animation();
  inline void set_has_scale();
  inline void set_has_collision_body();
  inline void set_has_velocity();
  inline void set_has_audio_source();
  inline void set_has_light();

  inline bool has_component() const;
  void clear_component();
  inline void clear_has_component();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ComponentUnion {
    ComponentUnion() {}
    ::tec::proto::Renderable* renderable_;
    ::tec::proto::Position* position_;
    ::tec::proto::Orientation* orientation_;
    ::tec::proto::View* view_;
    ::tec::proto::Animation* animation_;
    ::tec::proto::Scale* scale_;
    ::tec::proto::CollisionBody* collision_body_;
    ::tec::proto::Velocity* velocity_;
    ::tec::proto::AudioSource* audio_source_;
    ::tec::proto::Light* light_;
  } component_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Component* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  inline Entity* New() const { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // repeated .tec.proto.Component components = 2;
  int components_size() const;
  void clear_components();
  static const int kComponentsFieldNumber = 2;
  const ::tec::proto::Component& components(int index) const;
  ::tec::proto::Component* mutable_components(int index);
  ::tec::proto::Component* add_components();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
      components() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
      mutable_components();

  // @@protoc_insertion_point(class_scope:tec.proto.Entity)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Component > components_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class EntityList : public ::google::protobuf::Message {
 public:
  EntityList();
  virtual ~EntityList();

  EntityList(const EntityList& from);

  inline EntityList& operator=(const EntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityList& default_instance();

  void Swap(EntityList* other);

  // implements Message ----------------------------------------------

  inline EntityList* New() const { return New(NULL); }

  EntityList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityList& from);
  void MergeFrom(const EntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntityList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tec.proto.Entity entities = 1;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  const ::tec::proto::Entity& entities(int index) const;
  ::tec::proto::Entity* mutable_entities(int index);
  ::tec::proto::Entity* add_entities();
  const ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >&
      entities() const;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:tec.proto.EntityList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity > entities_;
  friend void  protobuf_AddDesc_components_2eproto();
  friend void protobuf_AssignDesc_components_2eproto();
  friend void protobuf_ShutdownFile_components_2eproto();

  void InitAsDefaultInstance();
  static EntityList* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Renderable

// optional string shader_name = 1;
inline bool Renderable::has_shader_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Renderable::set_has_shader_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Renderable::clear_has_shader_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Renderable::clear_shader_name() {
  shader_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_shader_name();
}
inline const ::std::string& Renderable::shader_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.shader_name)
  return shader_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_shader_name(const ::std::string& value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.shader_name)
}
inline void Renderable::set_shader_name(const char* value, size_t size) {
  set_has_shader_name();
  shader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.shader_name)
}
inline ::std::string* Renderable::mutable_shader_name() {
  set_has_shader_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.shader_name)
  return shader_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_shader_name() {
  clear_has_shader_name();
  return shader_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_shader_name(::std::string* shader_name) {
  if (shader_name != NULL) {
    set_has_shader_name();
  } else {
    clear_has_shader_name();
  }
  shader_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shader_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.shader_name)
}

// optional string mesh_name = 2;
inline bool Renderable::has_mesh_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Renderable::set_has_mesh_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Renderable::clear_has_mesh_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Renderable::clear_mesh_name() {
  mesh_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mesh_name();
}
inline const ::std::string& Renderable::mesh_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.mesh_name)
  return mesh_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_mesh_name(const ::std::string& value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Renderable.mesh_name)
}
inline void Renderable::set_mesh_name(const char* value, size_t size) {
  set_has_mesh_name();
  mesh_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Renderable.mesh_name)
}
inline ::std::string* Renderable::mutable_mesh_name() {
  set_has_mesh_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Renderable.mesh_name)
  return mesh_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Renderable::release_mesh_name() {
  clear_has_mesh_name();
  return mesh_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Renderable::set_allocated_mesh_name(::std::string* mesh_name) {
  if (mesh_name != NULL) {
    set_has_mesh_name();
  } else {
    clear_has_mesh_name();
  }
  mesh_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mesh_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Renderable.mesh_name)
}

// optional bool hidden = 3;
inline bool Renderable::has_hidden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Renderable::set_has_hidden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Renderable::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Renderable::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool Renderable::hidden() const {
  // @@protoc_insertion_point(field_get:tec.proto.Renderable.hidden)
  return hidden_;
}
inline void Renderable::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Renderable.hidden)
}

// -------------------------------------------------------------------

// Position

// optional float x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.x)
  return x_;
}
inline void Position::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.x)
}

// optional float y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.y)
  return y_;
}
inline void Position::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.y)
}

// optional float z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Position::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Position.z)
  return z_;
}
inline void Position::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Position.z)
}

// -------------------------------------------------------------------

// Orientation

// required float x = 1;
inline bool Orientation::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Orientation::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Orientation::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Orientation::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.x)
  return x_;
}
inline void Orientation::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.x)
}

// required float y = 2;
inline bool Orientation::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Orientation::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Orientation::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Orientation::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.y)
  return y_;
}
inline void Orientation::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.y)
}

// required float z = 3;
inline bool Orientation::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Orientation::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Orientation::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Orientation::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.z)
  return z_;
}
inline void Orientation::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.z)
}

// required float w = 4;
inline bool Orientation::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Orientation::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Orientation::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Orientation::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Orientation::w() const {
  // @@protoc_insertion_point(field_get:tec.proto.Orientation.w)
  return w_;
}
inline void Orientation::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Orientation.w)
}

// -------------------------------------------------------------------

// View

// optional bool active = 1;
inline bool View::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void View::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void View::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void View::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool View::active() const {
  // @@protoc_insertion_point(field_get:tec.proto.View.active)
  return active_;
}
inline void View::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.View.active)
}

// -------------------------------------------------------------------

// Animation

// optional string animation_name = 1;
inline bool Animation::has_animation_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Animation::set_has_animation_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Animation::clear_has_animation_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Animation::clear_animation_name() {
  animation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animation_name();
}
inline const ::std::string& Animation::animation_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.Animation.animation_name)
  return animation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Animation::set_animation_name(const ::std::string& value) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.Animation.animation_name)
}
inline void Animation::set_animation_name(const char* value) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.Animation.animation_name)
}
inline void Animation::set_animation_name(const char* value, size_t size) {
  set_has_animation_name();
  animation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.Animation.animation_name)
}
inline ::std::string* Animation::mutable_animation_name() {
  set_has_animation_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.Animation.animation_name)
  return animation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Animation::release_animation_name() {
  clear_has_animation_name();
  return animation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Animation::set_allocated_animation_name(::std::string* animation_name) {
  if (animation_name != NULL) {
    set_has_animation_name();
  } else {
    clear_has_animation_name();
  }
  animation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animation_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Animation.animation_name)
}

// -------------------------------------------------------------------

// Scale

// optional float x = 1;
inline bool Scale::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scale::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scale::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scale::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Scale::x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.x)
  return x_;
}
inline void Scale::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.x)
}

// optional float y = 2;
inline bool Scale::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scale::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scale::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scale::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Scale::y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.y)
  return y_;
}
inline void Scale::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.y)
}

// optional float z = 3;
inline bool Scale::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scale::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scale::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scale::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Scale::z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Scale.z)
  return z_;
}
inline void Scale::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Scale.z)
}

// -------------------------------------------------------------------

// CollisionBody_Box

// required float x_extent = 1;
inline bool CollisionBody_Box::has_x_extent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Box::set_has_x_extent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Box::clear_has_x_extent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Box::clear_x_extent() {
  x_extent_ = 0;
  clear_has_x_extent();
}
inline float CollisionBody_Box::x_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.x_extent)
  return x_extent_;
}
inline void CollisionBody_Box::set_x_extent(float value) {
  set_has_x_extent();
  x_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.x_extent)
}

// required float y_extent = 2;
inline bool CollisionBody_Box::has_y_extent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody_Box::set_has_y_extent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody_Box::clear_has_y_extent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody_Box::clear_y_extent() {
  y_extent_ = 0;
  clear_has_y_extent();
}
inline float CollisionBody_Box::y_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.y_extent)
  return y_extent_;
}
inline void CollisionBody_Box::set_y_extent(float value) {
  set_has_y_extent();
  y_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.y_extent)
}

// required float z_extent = 3;
inline bool CollisionBody_Box::has_z_extent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionBody_Box::set_has_z_extent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionBody_Box::clear_has_z_extent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionBody_Box::clear_z_extent() {
  z_extent_ = 0;
  clear_has_z_extent();
}
inline float CollisionBody_Box::z_extent() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Box.z_extent)
  return z_extent_;
}
inline void CollisionBody_Box::set_z_extent(float value) {
  set_has_z_extent();
  z_extent_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Box.z_extent)
}

// -------------------------------------------------------------------

// CollisionBody_Sphere

// required float radius = 1;
inline bool CollisionBody_Sphere::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Sphere::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Sphere::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Sphere::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CollisionBody_Sphere::radius() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Sphere.radius)
  return radius_;
}
inline void CollisionBody_Sphere::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Sphere.radius)
}

// -------------------------------------------------------------------

// CollisionBody_Capsule

// required float radius = 1;
inline bool CollisionBody_Capsule::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody_Capsule::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody_Capsule::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody_Capsule::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float CollisionBody_Capsule::radius() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Capsule.radius)
  return radius_;
}
inline void CollisionBody_Capsule::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Capsule.radius)
}

// required float height = 2;
inline bool CollisionBody_Capsule::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody_Capsule::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody_Capsule::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody_Capsule::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CollisionBody_Capsule::height() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.Capsule.height)
  return height_;
}
inline void CollisionBody_Capsule::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.Capsule.height)
}

// -------------------------------------------------------------------

// CollisionBody

// optional bool disable_deactivation = 1;
inline bool CollisionBody::has_disable_deactivation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionBody::set_has_disable_deactivation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionBody::clear_has_disable_deactivation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionBody::clear_disable_deactivation() {
  disable_deactivation_ = false;
  clear_has_disable_deactivation();
}
inline bool CollisionBody::disable_deactivation() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.disable_deactivation)
  return disable_deactivation_;
}
inline void CollisionBody::set_disable_deactivation(bool value) {
  set_has_disable_deactivation();
  disable_deactivation_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.disable_deactivation)
}

// optional bool disable_rotation = 2;
inline bool CollisionBody::has_disable_rotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionBody::set_has_disable_rotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionBody::clear_has_disable_rotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionBody::clear_disable_rotation() {
  disable_rotation_ = false;
  clear_has_disable_rotation();
}
inline bool CollisionBody::disable_rotation() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.disable_rotation)
  return disable_rotation_;
}
inline void CollisionBody::set_disable_rotation(bool value) {
  set_has_disable_rotation();
  disable_rotation_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.disable_rotation)
}

// optional .tec.proto.CollisionBody.Box box = 3;
inline bool CollisionBody::has_box() const {
  return shape_case() == kBox;
}
inline void CollisionBody::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void CollisionBody::clear_box() {
  if (has_box()) {
    delete shape_.box_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Box& CollisionBody::box() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.box)
  return has_box() ? *shape_.box_
                      : ::tec::proto::CollisionBody_Box::default_instance();
}
inline ::tec::proto::CollisionBody_Box* CollisionBody::mutable_box() {
  if (!has_box()) {
    clear_shape();
    set_has_box();
    shape_.box_ = new ::tec::proto::CollisionBody_Box;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.box)
  return shape_.box_;
}
inline ::tec::proto::CollisionBody_Box* CollisionBody::release_box() {
  if (has_box()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Box* temp = shape_.box_;
    shape_.box_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_box(::tec::proto::CollisionBody_Box* box) {
  clear_shape();
  if (box) {
    set_has_box();
    shape_.box_ = box;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.box)
}

// optional .tec.proto.CollisionBody.Sphere sphere = 4;
inline bool CollisionBody::has_sphere() const {
  return shape_case() == kSphere;
}
inline void CollisionBody::set_has_sphere() {
  _oneof_case_[0] = kSphere;
}
inline void CollisionBody::clear_sphere() {
  if (has_sphere()) {
    delete shape_.sphere_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Sphere& CollisionBody::sphere() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.sphere)
  return has_sphere() ? *shape_.sphere_
                      : ::tec::proto::CollisionBody_Sphere::default_instance();
}
inline ::tec::proto::CollisionBody_Sphere* CollisionBody::mutable_sphere() {
  if (!has_sphere()) {
    clear_shape();
    set_has_sphere();
    shape_.sphere_ = new ::tec::proto::CollisionBody_Sphere;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.sphere)
  return shape_.sphere_;
}
inline ::tec::proto::CollisionBody_Sphere* CollisionBody::release_sphere() {
  if (has_sphere()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Sphere* temp = shape_.sphere_;
    shape_.sphere_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_sphere(::tec::proto::CollisionBody_Sphere* sphere) {
  clear_shape();
  if (sphere) {
    set_has_sphere();
    shape_.sphere_ = sphere;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.sphere)
}

// optional .tec.proto.CollisionBody.Capsule capsule = 5;
inline bool CollisionBody::has_capsule() const {
  return shape_case() == kCapsule;
}
inline void CollisionBody::set_has_capsule() {
  _oneof_case_[0] = kCapsule;
}
inline void CollisionBody::clear_capsule() {
  if (has_capsule()) {
    delete shape_.capsule_;
    clear_has_shape();
  }
}
inline const ::tec::proto::CollisionBody_Capsule& CollisionBody::capsule() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.capsule)
  return has_capsule() ? *shape_.capsule_
                      : ::tec::proto::CollisionBody_Capsule::default_instance();
}
inline ::tec::proto::CollisionBody_Capsule* CollisionBody::mutable_capsule() {
  if (!has_capsule()) {
    clear_shape();
    set_has_capsule();
    shape_.capsule_ = new ::tec::proto::CollisionBody_Capsule;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.CollisionBody.capsule)
  return shape_.capsule_;
}
inline ::tec::proto::CollisionBody_Capsule* CollisionBody::release_capsule() {
  if (has_capsule()) {
    clear_has_shape();
    ::tec::proto::CollisionBody_Capsule* temp = shape_.capsule_;
    shape_.capsule_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CollisionBody::set_allocated_capsule(::tec::proto::CollisionBody_Capsule* capsule) {
  clear_shape();
  if (capsule) {
    set_has_capsule();
    shape_.capsule_ = capsule;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.CollisionBody.capsule)
}

// optional float mass = 6;
inline bool CollisionBody::has_mass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollisionBody::set_has_mass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollisionBody::clear_has_mass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollisionBody::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float CollisionBody::mass() const {
  // @@protoc_insertion_point(field_get:tec.proto.CollisionBody.mass)
  return mass_;
}
inline void CollisionBody::set_mass(float value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.CollisionBody.mass)
}

inline bool CollisionBody::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void CollisionBody::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline CollisionBody::ShapeCase CollisionBody::shape_case() const {
  return CollisionBody::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Velocity

// optional float linear_x = 1;
inline bool Velocity::has_linear_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Velocity::set_has_linear_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Velocity::clear_has_linear_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Velocity::clear_linear_x() {
  linear_x_ = 0;
  clear_has_linear_x();
}
inline float Velocity::linear_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_x)
  return linear_x_;
}
inline void Velocity::set_linear_x(float value) {
  set_has_linear_x();
  linear_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_x)
}

// optional float linear_y = 2;
inline bool Velocity::has_linear_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Velocity::set_has_linear_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Velocity::clear_has_linear_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Velocity::clear_linear_y() {
  linear_y_ = 0;
  clear_has_linear_y();
}
inline float Velocity::linear_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_y)
  return linear_y_;
}
inline void Velocity::set_linear_y(float value) {
  set_has_linear_y();
  linear_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_y)
}

// optional float linear_z = 3;
inline bool Velocity::has_linear_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Velocity::set_has_linear_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Velocity::clear_has_linear_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Velocity::clear_linear_z() {
  linear_z_ = 0;
  clear_has_linear_z();
}
inline float Velocity::linear_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.linear_z)
  return linear_z_;
}
inline void Velocity::set_linear_z(float value) {
  set_has_linear_z();
  linear_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.linear_z)
}

// optional float angular_x = 4;
inline bool Velocity::has_angular_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Velocity::set_has_angular_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Velocity::clear_has_angular_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Velocity::clear_angular_x() {
  angular_x_ = 0;
  clear_has_angular_x();
}
inline float Velocity::angular_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_x)
  return angular_x_;
}
inline void Velocity::set_angular_x(float value) {
  set_has_angular_x();
  angular_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_x)
}

// optional float angular_y = 5;
inline bool Velocity::has_angular_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Velocity::set_has_angular_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Velocity::clear_has_angular_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Velocity::clear_angular_y() {
  angular_y_ = 0;
  clear_has_angular_y();
}
inline float Velocity::angular_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_y)
  return angular_y_;
}
inline void Velocity::set_angular_y(float value) {
  set_has_angular_y();
  angular_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_y)
}

// optional float angular_z = 6;
inline bool Velocity::has_angular_z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Velocity::set_has_angular_z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Velocity::clear_has_angular_z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Velocity::clear_angular_z() {
  angular_z_ = 0;
  clear_has_angular_z();
}
inline float Velocity::angular_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Velocity.angular_z)
  return angular_z_;
}
inline void Velocity::set_angular_z(float value) {
  set_has_angular_z();
  angular_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Velocity.angular_z)
}

// -------------------------------------------------------------------

// AudioSource

// optional bool looping = 1;
inline bool AudioSource::has_looping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioSource::set_has_looping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioSource::clear_has_looping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioSource::clear_looping() {
  looping_ = false;
  clear_has_looping();
}
inline bool AudioSource::looping() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.looping)
  return looping_;
}
inline void AudioSource::set_looping(bool value) {
  set_has_looping();
  looping_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.looping)
}

// optional string audio_name = 2;
inline bool AudioSource::has_audio_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioSource::set_has_audio_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioSource::clear_has_audio_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioSource::clear_audio_name() {
  audio_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_audio_name();
}
inline const ::std::string& AudioSource::audio_name() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.audio_name)
  return audio_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioSource::set_audio_name(const ::std::string& value) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.audio_name)
}
inline void AudioSource::set_audio_name(const char* value) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tec.proto.AudioSource.audio_name)
}
inline void AudioSource::set_audio_name(const char* value, size_t size) {
  set_has_audio_name();
  audio_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tec.proto.AudioSource.audio_name)
}
inline ::std::string* AudioSource::mutable_audio_name() {
  set_has_audio_name();
  // @@protoc_insertion_point(field_mutable:tec.proto.AudioSource.audio_name)
  return audio_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioSource::release_audio_name() {
  clear_has_audio_name();
  return audio_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioSource::set_allocated_audio_name(::std::string* audio_name) {
  if (audio_name != NULL) {
    set_has_audio_name();
  } else {
    clear_has_audio_name();
  }
  audio_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio_name);
  // @@protoc_insertion_point(field_set_allocated:tec.proto.AudioSource.audio_name)
}

// optional bool playing = 3;
inline bool AudioSource::has_playing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioSource::set_has_playing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioSource::clear_has_playing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioSource::clear_playing() {
  playing_ = false;
  clear_has_playing();
}
inline bool AudioSource::playing() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.playing)
  return playing_;
}
inline void AudioSource::set_playing(bool value) {
  set_has_playing();
  playing_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.playing)
}

// optional uint32 volume = 4;
inline bool AudioSource::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioSource::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioSource::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioSource::clear_volume() {
  volume_ = 0u;
  clear_has_volume();
}
inline ::google::protobuf::uint32 AudioSource::volume() const {
  // @@protoc_insertion_point(field_get:tec.proto.AudioSource.volume)
  return volume_;
}
inline void AudioSource::set_volume(::google::protobuf::uint32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.AudioSource.volume)
}

// -------------------------------------------------------------------

// Light_Attenuation

// optional float constant = 1;
inline bool Light_Attenuation::has_constant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light_Attenuation::set_has_constant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light_Attenuation::clear_has_constant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light_Attenuation::clear_constant() {
  constant_ = 0;
  clear_has_constant();
}
inline float Light_Attenuation::constant() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.constant)
  return constant_;
}
inline void Light_Attenuation::set_constant(float value) {
  set_has_constant();
  constant_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.constant)
}

// optional float linear = 2;
inline bool Light_Attenuation::has_linear() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light_Attenuation::set_has_linear() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light_Attenuation::clear_has_linear() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light_Attenuation::clear_linear() {
  linear_ = 0;
  clear_has_linear();
}
inline float Light_Attenuation::linear() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.linear)
  return linear_;
}
inline void Light_Attenuation::set_linear(float value) {
  set_has_linear();
  linear_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.linear)
}

// optional float exponential = 3;
inline bool Light_Attenuation::has_exponential() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light_Attenuation::set_has_exponential() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light_Attenuation::clear_has_exponential() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light_Attenuation::clear_exponential() {
  exponential_ = 0;
  clear_has_exponential();
}
inline float Light_Attenuation::exponential() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.Attenuation.exponential)
  return exponential_;
}
inline void Light_Attenuation::set_exponential(float value) {
  set_has_exponential();
  exponential_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.Attenuation.exponential)
}

// -------------------------------------------------------------------

// Light

// optional float color_x = 1;
inline bool Light::has_color_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Light::set_has_color_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Light::clear_has_color_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Light::clear_color_x() {
  color_x_ = 0;
  clear_has_color_x();
}
inline float Light::color_x() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_x)
  return color_x_;
}
inline void Light::set_color_x(float value) {
  set_has_color_x();
  color_x_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_x)
}

// optional float color_y = 2;
inline bool Light::has_color_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Light::set_has_color_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Light::clear_has_color_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Light::clear_color_y() {
  color_y_ = 0;
  clear_has_color_y();
}
inline float Light::color_y() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_y)
  return color_y_;
}
inline void Light::set_color_y(float value) {
  set_has_color_y();
  color_y_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_y)
}

// optional float color_z = 3;
inline bool Light::has_color_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Light::set_has_color_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Light::clear_has_color_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Light::clear_color_z() {
  color_z_ = 0;
  clear_has_color_z();
}
inline float Light::color_z() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.color_z)
  return color_z_;
}
inline void Light::set_color_z(float value) {
  set_has_color_z();
  color_z_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.color_z)
}

// optional float ambient_intensity = 4;
inline bool Light::has_ambient_intensity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Light::set_has_ambient_intensity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Light::clear_has_ambient_intensity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Light::clear_ambient_intensity() {
  ambient_intensity_ = 0;
  clear_has_ambient_intensity();
}
inline float Light::ambient_intensity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.ambient_intensity)
  return ambient_intensity_;
}
inline void Light::set_ambient_intensity(float value) {
  set_has_ambient_intensity();
  ambient_intensity_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.ambient_intensity)
}

// optional float diffuse_intensity = 5;
inline bool Light::has_diffuse_intensity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Light::set_has_diffuse_intensity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Light::clear_has_diffuse_intensity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Light::clear_diffuse_intensity() {
  diffuse_intensity_ = 0;
  clear_has_diffuse_intensity();
}
inline float Light::diffuse_intensity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.diffuse_intensity)
  return diffuse_intensity_;
}
inline void Light::set_diffuse_intensity(float value) {
  set_has_diffuse_intensity();
  diffuse_intensity_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.diffuse_intensity)
}

// optional .tec.proto.Light.Attenuation attenuation = 6;
inline bool Light::has_attenuation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Light::set_has_attenuation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Light::clear_has_attenuation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Light::clear_attenuation() {
  if (attenuation_ != NULL) attenuation_->::tec::proto::Light_Attenuation::Clear();
  clear_has_attenuation();
}
inline const ::tec::proto::Light_Attenuation& Light::attenuation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.attenuation)
  return attenuation_ != NULL ? *attenuation_ : *default_instance_->attenuation_;
}
inline ::tec::proto::Light_Attenuation* Light::mutable_attenuation() {
  set_has_attenuation();
  if (attenuation_ == NULL) {
    attenuation_ = new ::tec::proto::Light_Attenuation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Light.attenuation)
  return attenuation_;
}
inline ::tec::proto::Light_Attenuation* Light::release_attenuation() {
  clear_has_attenuation();
  ::tec::proto::Light_Attenuation* temp = attenuation_;
  attenuation_ = NULL;
  return temp;
}
inline void Light::set_allocated_attenuation(::tec::proto::Light_Attenuation* attenuation) {
  delete attenuation_;
  attenuation_ = attenuation;
  if (attenuation) {
    set_has_attenuation();
  } else {
    clear_has_attenuation();
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Light.attenuation)
}

// optional float cutoff = 7;
inline bool Light::has_cutoff() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Light::set_has_cutoff() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Light::clear_has_cutoff() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Light::clear_cutoff() {
  cutoff_ = 0;
  clear_has_cutoff();
}
inline float Light::cutoff() const {
  // @@protoc_insertion_point(field_get:tec.proto.Light.cutoff)
  return cutoff_;
}
inline void Light::set_cutoff(float value) {
  set_has_cutoff();
  cutoff_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Light.cutoff)
}

// -------------------------------------------------------------------

// Component

// optional .tec.proto.Renderable renderable = 1;
inline bool Component::has_renderable() const {
  return component_case() == kRenderable;
}
inline void Component::set_has_renderable() {
  _oneof_case_[0] = kRenderable;
}
inline void Component::clear_renderable() {
  if (has_renderable()) {
    delete component_.renderable_;
    clear_has_component();
  }
}
inline const ::tec::proto::Renderable& Component::renderable() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.renderable)
  return has_renderable() ? *component_.renderable_
                      : ::tec::proto::Renderable::default_instance();
}
inline ::tec::proto::Renderable* Component::mutable_renderable() {
  if (!has_renderable()) {
    clear_component();
    set_has_renderable();
    component_.renderable_ = new ::tec::proto::Renderable;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.renderable)
  return component_.renderable_;
}
inline ::tec::proto::Renderable* Component::release_renderable() {
  if (has_renderable()) {
    clear_has_component();
    ::tec::proto::Renderable* temp = component_.renderable_;
    component_.renderable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_renderable(::tec::proto::Renderable* renderable) {
  clear_component();
  if (renderable) {
    set_has_renderable();
    component_.renderable_ = renderable;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.renderable)
}

// optional .tec.proto.Position position = 2;
inline bool Component::has_position() const {
  return component_case() == kPosition;
}
inline void Component::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void Component::clear_position() {
  if (has_position()) {
    delete component_.position_;
    clear_has_component();
  }
}
inline const ::tec::proto::Position& Component::position() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.position)
  return has_position() ? *component_.position_
                      : ::tec::proto::Position::default_instance();
}
inline ::tec::proto::Position* Component::mutable_position() {
  if (!has_position()) {
    clear_component();
    set_has_position();
    component_.position_ = new ::tec::proto::Position;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.position)
  return component_.position_;
}
inline ::tec::proto::Position* Component::release_position() {
  if (has_position()) {
    clear_has_component();
    ::tec::proto::Position* temp = component_.position_;
    component_.position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_position(::tec::proto::Position* position) {
  clear_component();
  if (position) {
    set_has_position();
    component_.position_ = position;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.position)
}

// optional .tec.proto.Orientation orientation = 3;
inline bool Component::has_orientation() const {
  return component_case() == kOrientation;
}
inline void Component::set_has_orientation() {
  _oneof_case_[0] = kOrientation;
}
inline void Component::clear_orientation() {
  if (has_orientation()) {
    delete component_.orientation_;
    clear_has_component();
  }
}
inline const ::tec::proto::Orientation& Component::orientation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.orientation)
  return has_orientation() ? *component_.orientation_
                      : ::tec::proto::Orientation::default_instance();
}
inline ::tec::proto::Orientation* Component::mutable_orientation() {
  if (!has_orientation()) {
    clear_component();
    set_has_orientation();
    component_.orientation_ = new ::tec::proto::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.orientation)
  return component_.orientation_;
}
inline ::tec::proto::Orientation* Component::release_orientation() {
  if (has_orientation()) {
    clear_has_component();
    ::tec::proto::Orientation* temp = component_.orientation_;
    component_.orientation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_orientation(::tec::proto::Orientation* orientation) {
  clear_component();
  if (orientation) {
    set_has_orientation();
    component_.orientation_ = orientation;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.orientation)
}

// optional .tec.proto.View view = 4;
inline bool Component::has_view() const {
  return component_case() == kView;
}
inline void Component::set_has_view() {
  _oneof_case_[0] = kView;
}
inline void Component::clear_view() {
  if (has_view()) {
    delete component_.view_;
    clear_has_component();
  }
}
inline const ::tec::proto::View& Component::view() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.view)
  return has_view() ? *component_.view_
                      : ::tec::proto::View::default_instance();
}
inline ::tec::proto::View* Component::mutable_view() {
  if (!has_view()) {
    clear_component();
    set_has_view();
    component_.view_ = new ::tec::proto::View;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.view)
  return component_.view_;
}
inline ::tec::proto::View* Component::release_view() {
  if (has_view()) {
    clear_has_component();
    ::tec::proto::View* temp = component_.view_;
    component_.view_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_view(::tec::proto::View* view) {
  clear_component();
  if (view) {
    set_has_view();
    component_.view_ = view;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.view)
}

// optional .tec.proto.Animation animation = 5;
inline bool Component::has_animation() const {
  return component_case() == kAnimation;
}
inline void Component::set_has_animation() {
  _oneof_case_[0] = kAnimation;
}
inline void Component::clear_animation() {
  if (has_animation()) {
    delete component_.animation_;
    clear_has_component();
  }
}
inline const ::tec::proto::Animation& Component::animation() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.animation)
  return has_animation() ? *component_.animation_
                      : ::tec::proto::Animation::default_instance();
}
inline ::tec::proto::Animation* Component::mutable_animation() {
  if (!has_animation()) {
    clear_component();
    set_has_animation();
    component_.animation_ = new ::tec::proto::Animation;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.animation)
  return component_.animation_;
}
inline ::tec::proto::Animation* Component::release_animation() {
  if (has_animation()) {
    clear_has_component();
    ::tec::proto::Animation* temp = component_.animation_;
    component_.animation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_animation(::tec::proto::Animation* animation) {
  clear_component();
  if (animation) {
    set_has_animation();
    component_.animation_ = animation;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.animation)
}

// optional .tec.proto.Scale Scale = 6;
inline bool Component::has_scale() const {
  return component_case() == kScale;
}
inline void Component::set_has_scale() {
  _oneof_case_[0] = kScale;
}
inline void Component::clear_scale() {
  if (has_scale()) {
    delete component_.scale_;
    clear_has_component();
  }
}
inline const ::tec::proto::Scale& Component::scale() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.Scale)
  return has_scale() ? *component_.scale_
                      : ::tec::proto::Scale::default_instance();
}
inline ::tec::proto::Scale* Component::mutable_scale() {
  if (!has_scale()) {
    clear_component();
    set_has_scale();
    component_.scale_ = new ::tec::proto::Scale;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.Scale)
  return component_.scale_;
}
inline ::tec::proto::Scale* Component::release_scale() {
  if (has_scale()) {
    clear_has_component();
    ::tec::proto::Scale* temp = component_.scale_;
    component_.scale_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_scale(::tec::proto::Scale* scale) {
  clear_component();
  if (scale) {
    set_has_scale();
    component_.scale_ = scale;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.Scale)
}

// optional .tec.proto.CollisionBody collision_body = 7;
inline bool Component::has_collision_body() const {
  return component_case() == kCollisionBody;
}
inline void Component::set_has_collision_body() {
  _oneof_case_[0] = kCollisionBody;
}
inline void Component::clear_collision_body() {
  if (has_collision_body()) {
    delete component_.collision_body_;
    clear_has_component();
  }
}
inline const ::tec::proto::CollisionBody& Component::collision_body() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.collision_body)
  return has_collision_body() ? *component_.collision_body_
                      : ::tec::proto::CollisionBody::default_instance();
}
inline ::tec::proto::CollisionBody* Component::mutable_collision_body() {
  if (!has_collision_body()) {
    clear_component();
    set_has_collision_body();
    component_.collision_body_ = new ::tec::proto::CollisionBody;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.collision_body)
  return component_.collision_body_;
}
inline ::tec::proto::CollisionBody* Component::release_collision_body() {
  if (has_collision_body()) {
    clear_has_component();
    ::tec::proto::CollisionBody* temp = component_.collision_body_;
    component_.collision_body_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_collision_body(::tec::proto::CollisionBody* collision_body) {
  clear_component();
  if (collision_body) {
    set_has_collision_body();
    component_.collision_body_ = collision_body;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.collision_body)
}

// optional .tec.proto.Velocity velocity = 8;
inline bool Component::has_velocity() const {
  return component_case() == kVelocity;
}
inline void Component::set_has_velocity() {
  _oneof_case_[0] = kVelocity;
}
inline void Component::clear_velocity() {
  if (has_velocity()) {
    delete component_.velocity_;
    clear_has_component();
  }
}
inline const ::tec::proto::Velocity& Component::velocity() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.velocity)
  return has_velocity() ? *component_.velocity_
                      : ::tec::proto::Velocity::default_instance();
}
inline ::tec::proto::Velocity* Component::mutable_velocity() {
  if (!has_velocity()) {
    clear_component();
    set_has_velocity();
    component_.velocity_ = new ::tec::proto::Velocity;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.velocity)
  return component_.velocity_;
}
inline ::tec::proto::Velocity* Component::release_velocity() {
  if (has_velocity()) {
    clear_has_component();
    ::tec::proto::Velocity* temp = component_.velocity_;
    component_.velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_velocity(::tec::proto::Velocity* velocity) {
  clear_component();
  if (velocity) {
    set_has_velocity();
    component_.velocity_ = velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.velocity)
}

// optional .tec.proto.AudioSource audio_source = 9;
inline bool Component::has_audio_source() const {
  return component_case() == kAudioSource;
}
inline void Component::set_has_audio_source() {
  _oneof_case_[0] = kAudioSource;
}
inline void Component::clear_audio_source() {
  if (has_audio_source()) {
    delete component_.audio_source_;
    clear_has_component();
  }
}
inline const ::tec::proto::AudioSource& Component::audio_source() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.audio_source)
  return has_audio_source() ? *component_.audio_source_
                      : ::tec::proto::AudioSource::default_instance();
}
inline ::tec::proto::AudioSource* Component::mutable_audio_source() {
  if (!has_audio_source()) {
    clear_component();
    set_has_audio_source();
    component_.audio_source_ = new ::tec::proto::AudioSource;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.audio_source)
  return component_.audio_source_;
}
inline ::tec::proto::AudioSource* Component::release_audio_source() {
  if (has_audio_source()) {
    clear_has_component();
    ::tec::proto::AudioSource* temp = component_.audio_source_;
    component_.audio_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_audio_source(::tec::proto::AudioSource* audio_source) {
  clear_component();
  if (audio_source) {
    set_has_audio_source();
    component_.audio_source_ = audio_source;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.audio_source)
}

// optional .tec.proto.Light light = 10;
inline bool Component::has_light() const {
  return component_case() == kLight;
}
inline void Component::set_has_light() {
  _oneof_case_[0] = kLight;
}
inline void Component::clear_light() {
  if (has_light()) {
    delete component_.light_;
    clear_has_component();
  }
}
inline const ::tec::proto::Light& Component::light() const {
  // @@protoc_insertion_point(field_get:tec.proto.Component.light)
  return has_light() ? *component_.light_
                      : ::tec::proto::Light::default_instance();
}
inline ::tec::proto::Light* Component::mutable_light() {
  if (!has_light()) {
    clear_component();
    set_has_light();
    component_.light_ = new ::tec::proto::Light;
  }
  // @@protoc_insertion_point(field_mutable:tec.proto.Component.light)
  return component_.light_;
}
inline ::tec::proto::Light* Component::release_light() {
  if (has_light()) {
    clear_has_component();
    ::tec::proto::Light* temp = component_.light_;
    component_.light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Component::set_allocated_light(::tec::proto::Light* light) {
  clear_component();
  if (light) {
    set_has_light();
    component_.light_ = light;
  }
  // @@protoc_insertion_point(field_set_allocated:tec.proto.Component.light)
}

inline bool Component::has_component() const {
  return component_case() != COMPONENT_NOT_SET;
}
inline void Component::clear_has_component() {
  _oneof_case_[0] = COMPONENT_NOT_SET;
}
inline Component::ComponentCase Component::component_case() const {
  return Component::ComponentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Entity

// required uint64 id = 1;
inline bool Entity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Entity::id() const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.id)
  return id_;
}
inline void Entity::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tec.proto.Entity.id)
}

// repeated .tec.proto.Component components = 2;
inline int Entity::components_size() const {
  return components_.size();
}
inline void Entity::clear_components() {
  components_.Clear();
}
inline const ::tec::proto::Component& Entity::components(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.Entity.components)
  return components_.Get(index);
}
inline ::tec::proto::Component* Entity::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.Entity.components)
  return components_.Mutable(index);
}
inline ::tec::proto::Component* Entity::add_components() {
  // @@protoc_insertion_point(field_add:tec.proto.Entity.components)
  return components_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >&
Entity::components() const {
  // @@protoc_insertion_point(field_list:tec.proto.Entity.components)
  return components_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Component >*
Entity::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.Entity.components)
  return &components_;
}

// -------------------------------------------------------------------

// EntityList

// repeated .tec.proto.Entity entities = 1;
inline int EntityList::entities_size() const {
  return entities_.size();
}
inline void EntityList::clear_entities() {
  entities_.Clear();
}
inline const ::tec::proto::Entity& EntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:tec.proto.EntityList.entities)
  return entities_.Get(index);
}
inline ::tec::proto::Entity* EntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:tec.proto.EntityList.entities)
  return entities_.Mutable(index);
}
inline ::tec::proto::Entity* EntityList::add_entities() {
  // @@protoc_insertion_point(field_add:tec.proto.EntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >&
EntityList::entities() const {
  // @@protoc_insertion_point(field_list:tec.proto.EntityList.entities)
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::tec::proto::Entity >*
EntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:tec.proto.EntityList.entities)
  return &entities_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tec

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_components_2eproto__INCLUDED
